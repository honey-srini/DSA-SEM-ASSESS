STACK ARR
#include<stdio.h>

#include<stdlib.h>
 
#define Size 4 
 
int Top=-1, arr[Size];
void Push();
void Pop();
void isempty();
void top();
void show();
void search();
 
int main()
{
	int choice;
	
	while(1)	
	{
        printf("\n");
		printf("\nSTACK OPERATIONS :");
		printf("\n1.Push the element");
        printf("\n2.Pop the element");
        printf("\n3.Check the stack is empty or not");
        printf("\n4.Top element");
        printf("\n5.Show");
		printf("\n6.Search");
        printf("\n7.Exit");
		printf("\n\nEnter the choice:");
		scanf("%d",&choice);
		
		switch(choice)
		{
			case 1: 
            Push();
			break;

			case 2: 
            Pop();
			break;

			case 3:
            isempty();
			break;

            case 4:
            top();
            break;

            case 5:
            show();
            break;

			case 6:
            search();
            break;

			case 7: 
            exit(0);
			
			default:
            printf("\nInvalid choice!!");
		}
	}
}
 
void Push()
{
	int x;
	
	if(Top==Size-1)
	{
		printf("\nOverflow!!");
	}
	else
	{
		printf("\nEnter element to be inserted to the stack:");
		scanf("%d",&x);
		Top=Top+1;
		arr[Top]=x;
	}
}
 
void Pop()
{
	if(Top==-1)
	{
		printf("\nUnderflow!!");
	}
	else
	{
		printf("\nPopped element:  %d",arr[Top]);
		Top=Top-1;
	}
}

void isempty()
{
    if(Top==-1)
	{
		printf("\nThe Stack is Empty\n");
	}

    else
    {
        printf("\nThe stack is Not Empty\n");
    }

}
 
void top()
{
    printf("\nThe top of the Stack is :%d",arr[Top]);

}

void show()
{
	
	if(Top==-1)
	{
		printf("\nUnderflow!!");
	}
	else
	{
		printf("\nElements present in the stack: \n");
		for(int i=Top;i>=0;--i)
			printf("%d\n",arr[i]);
	}
}

void search()
{
	int n,i;
	if(Top==-1)
	{
		printf("\nUnderflow!!");
	}
	else
	{
		printf("Enter the element to be searched :");
		scanf("%d",&n);
		
		for(i=0;i<=Top;i++)
		{
			if(arr[i]==n)
			{
				printf("%d element is in the location %d ",arr[i],i );
				break;
			}
			else if(i==Top)
			{
				printf("element not found");
			}
			
		}
		
	}
}

---------------

STACK LL
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
struct ll
{
    int data;
    struct ll* next;
};

struct ll *head = NULL;
int top = -1;

struct ll* addtoll(int value, struct ll* ptr){
    struct ll* node = malloc(sizeof(struct ll));
    node->data = value;

    if (ptr == NULL)
    {
        node->next = NULL;
        ptr = node;
        return ptr;
    }
    else if (ptr != NULL)
    {
        node->next = ptr;
        ptr = node;
        return ptr;
    }    
}

struct ll* deletefromll(struct ll* ptr){
    struct ll* temp = ptr->next;
    printf("The element pop is %d\n",ptr->data);
    free(ptr);
    ptr = temp;
    return ptr;
}

void displayll(struct ll* ptr){
    if (ptr==NULL)
    {
        printf("Stack is empty. No data to display\n");
    }
    else
    {
        printf("Data in the Linked List\n");
        while (ptr!=NULL)
        {
            printf("%d\n",ptr->data);
            ptr = ptr->next;
        }
    }
}

void push(struct ll* ptr){
    int value;
    printf("Enter value to be added to stack ");
    scanf("%d",&value);
    ptr = addtoll(value,ptr);
    head = ptr;
    top++;
}

void pop(struct ll* ptr){
    if (ptr==NULL)
    {
        printf("There is no element to pop\n");
    }
    else
    {
        head = deletefromll(ptr);
        top--;
    }
}

void peek(struct ll* ptr){
    if (top==-1)
    {
        printf("UNDERFLOW\n");
    }
    else
    {
        printf("The peek element is %d\n",ptr->data);
    }
}

bool isEmpyty(struct ll* ptr){
    if (ptr==NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}

int sizeofstack(struct ll* ptr){
    if (ptr==NULL)
    {
        return 0;
    }
    else
    {
        int counter = 0;
        while (ptr!=NULL)
        {
            ptr = ptr->next;
            counter++;
        }
        return counter;
    }
}

void search(struct ll *ptr)
{
    struct ll *temp =ptr;
    int key;
    printf("Enter element to be searched ");
    scanf("%d",&key);
    // printf(temp);
    int count =1;

    //iterate the entire linked list and print the data
    while(temp != NULL)
    {
         //key found return 1.
         if(temp->data == key)
         count=count+1;
         printf("element is found in the linked list1 %d position",count);
        
         temp = temp->next;
         break;
    }
    //key not found
    // printf("element not in the linked list");
}

void main(){
    int choice;
    printf("\n");
    printf("Stack Operations\n");
    printf("1. PUSH\n");
    printf("2. DISPLAY\n");
    printf("3. POP\n");
    printf("4. PEEK\n");
    printf("5. ISEMPTY\n");
    printf("6. SIZE OF STACK\n");
    printf("7. SEARCH AN ELEMENT\n");
    printf("8. EXIT\n");
    printf("Enter your choice number\n");
    scanf("%d",&choice);

    switch (choice)
    {
    case 1:
        push(head);
        main();
    case 2:
        displayll(head);
        main();
    case 3:
        pop(head);
        main();
    case 4:
        peek(head);
        main();
    case 5:
        if (isEmpyty(head))
        {
            printf("True\n");
        }
        else
        {
            printf("False\n");
        }
        main(); 
    case 6:
        printf("The size of stack is %d\n",sizeofstack(head));
        main();  
    case 7:
        search(head);
        main();           
    case 8:
        exit(0);
        break;    
    default:
        printf("Wrong Choice! Enter a valid number\n");
        main();
    }
}
---------------

QUEUE ARR
#include<stdio.h>   
#include<stdlib.h>  
#define maxsize 5  
void insert();  
void delete();  
void display();  
int front = -1, rear = -1;  
int queue[maxsize];  
void main ()  
{  
    int choice;   
    while(choice != 6)   
    {   
        printf("\n Queue Operations using Array\n");
        printf("1:Inserting element to queue(enqueue)\n");
        printf("2:Deleting element from queue(dequeue)\n");
        printf("3:Display all the elements of queue \n");
        printf("4.Display front element:\n");
        printf("5.Enter the element to be searched in the queue:\n");
        printf("6:Exit \n");
        
        printf("\nEnter your choice :");  
        scanf("%d",&choice);  
        switch(choice)  
        {  
            case 1:  
            insert();  
            break;  
            case 2:  
            delete();  
            break;  
            case 3:  
            display();  
            break; 
            case 4:  
            frontval();  
            break; 
            case 5:  
            search();  
            break;   
            case 6:  
            exit(0);  
            break;  
            default:   
            printf("\nEnter a valid choice!!!\n");  
        }  
    }  
}  
void insert()  
{  
    int item;  
    printf("\nEnter the element:");  
    scanf("\n%d",&item);      
    if(rear == maxsize-1)  
    {  
        printf("\nOVERFLOW\n");  
        return;  
    }  
    if(front == -1 && rear == -1)  
    {  
        front = 0;  
        rear = 0;  
    }  
    else   
    {  
        rear = rear+1;  
    }  
    queue[rear] = item;  
    printf("\nValue inserted into queue \n");  
      
}  
void delete()  
{  
    int item;   
    if (front == -1 || front > rear)  
    {  
        printf("\nUNDERFLOW\n");  
        return;  
              
    }  
    else  
    {  
        item = queue[front];  
        if(front == rear)  
        {  
            front = -1;  
            rear = -1 ;  
        }  
        else   
        {  
            front = front + 1;  
        }  
        printf("\nvalue deleted from the queue \n");  
    }  
      
      
}  
      
void display()  
{  
    int i;  
    if(rear == -1)  
    {  
        printf("\nEmpty queue\n");  
    }  
    else  
    {   printf("\nElements in the queue\n");  
        for(i=front;i<=rear;i++)  
        {  
            printf("%d\n",queue[i]);  
        }     
    }  
}  

void frontval(){
    if (front==-1)
    {
        printf("\nQueue is empty!");
    }
    else
    {
        printf("\nThe front element is %d \n",queue[front]);
    }
}

void search()
{
	int n,i;
	if(rear==-1)
	{
		printf("\nEmpty queue");
	}
	else
	{
		printf("Enter the element to be searched :");
		scanf("%d",&n);
		
		for(i=0;i<=rear;i++)
		{
			if(queue[i]==n)
			{
				printf("%d element is in the location %d \n",queue[i],i );
				break;
			}
			else if(i==rear)
			{
				printf("element not found");
			}
			
		}
		
	}
}

-----------

QUEUE LL

#include<stdio.h>
#include<stdlib.h>
struct node
{
    int data;
    struct node *next;
};
struct node *front=NULL;
struct node *rear=NULL;
void ins_que()
{
    int num;
    printf("Enter the element to be inserted:");
    scanf("%d",&num);
    struct node* newnode;
    newnode=(struct node*)malloc(sizeof(struct node));
    newnode->data=num;
    newnode->next=NULL;
    if(front==NULL && rear==NULL)
    {
        front=rear=newnode;
        printf("First value inserted\n");
    }
    else
    {
        rear->next=newnode;
        rear=newnode;
        printf("Value is inserted\n");
    }
}
void del_que()
{
    struct node* temp=front;
    if(front==NULL)
    {
        printf("Queue underflow\n");
    }
    else
    { 
        printf("Deleted Element:%d \n",front->data);
        front=front->next;
        free(temp);
    }
}
void search_que()
{
     int search_no,index=0;
     struct  node*temp=front;
     printf("Enter the element to be searched:");
     scanf("%d",&search_no);
     if(front==NULL)
     {
        printf("Queue underflow\n");
     }
     else
     {
        while(temp!=NULL)
        {
            index+=1;
            if(temp->data==search_no)
            {
            printf("Element found at index:%d",index);
            }
            temp=temp->next;
        }
        
    
     }
     
     
}
void display()
{
    struct node* temp;
    temp=front;
    if(front==NULL)
    {
        printf("Queue underflow\n");
    }
    else
    {
        
        printf("Elements present:\n");
        while(temp->next!=NULL)
        {
            printf("%d-->",temp->data);
            temp=temp->next;
        }
        printf("%d-->NULL\n",temp->data);
        
    }
    
}
void peek()
{
    if(front==NULL)
    {
        printf("Queue underflow\n");
    }
    else
    {
        printf("Top element:%d \n",front->data);
    }
}
int main()
{
    int choice;
    
    while(1)
    {
        printf("\n Queue Operations using Linked List\n");
        printf("\n1:Inserting element to queue(enqueue)\n");
        printf("2:Deleting element from queue(dequeue)\n");
        printf("3.Enter the element to be searched in the queue:\n");
        printf("4:Display all the elements of queue \n");
        printf("5.Display front element(peek):\n");
    
        printf("6:Exit \n");
        printf("\nEnter your choice\n");
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:
            ins_que();
            break;
            case 2:
            del_que();
            break;
            case 3:
            search_que();
            break;
            case 4:
            display();
            break;
            case 5:
            peek();
            break;
            case 6:
            exit(0);
            break;
            default:
            printf("Invalid choice\n");
        }

    }
    return 0;
}

--------------

LL OPERATIONS


#include<stdio.h>
#include<stdlib.h>

typedef struct linkedlist{
	int data;
	struct linkedlist *next;
}node;
void display(node *head);
void create();
void add_beg();
void add_end();
void add_before();
void add_after();
void add_pos();
void delete_beg();
void delete_end();
void delete_after();
void delete_before();
void delete_pos();
void search();
node *head = NULL;
int num,n,count;

void create(){
	node *new,*temp;
	printf("Enter the number of nodes you want to create: ");
	scanf("%d", &n);
	new = (node*) malloc(sizeof(node));
	if(new == NULL){
		printf("No memory");
	}
	else{
		printf("Element[1]: ");
		scanf("%d", &num);
		new->data = num;
		new->next = NULL;
		head = new;
		temp = head;
		count = 1;
		for(int i = 2; i <= n; i++){
			new = (node*) malloc(sizeof(node));
			if(new == NULL){
			printf("No Memory");
			}
			else {
			printf("Element[%d]: ", i);
			scanf("%d", &num);
			new->data = num;
			new->next = NULL;
			temp->next = new;
			temp = temp ->next;
			count++;
			}
		}
	}
	display(head);
}

void display(node *head){

	node *temp = head;
	if (temp == NULL){
		printf("There is no linked list");
	}
	else{
	while(temp != NULL){
		printf("\n%d", temp->data);
		temp = temp->next;
	}
	}
	printf("\nCount : %d\n", count);
}

void  add_beg(){
	node *new;
	new = (node*) malloc(sizeof(node));
	if(new == NULL){
	printf("No Memory");
	}
	else{
	printf("\nEnter the element you want to add in beginning : ");
	scanf("%d", &num);
	new->data = num;
	new->next = head;
	head = new;
	count++;
	}
	display(head);
}

void add_end(){
	node *new,*temp;
	temp = head;
	new = (node*) malloc(sizeof(node));
	if(new == NULL){
		printf("No Memory");
	}
	else{
		printf("\nEnter the element you want to add at the end : ");
		scanf("%d", &num);
		new->data = num;
		new->next = NULL;
		while(temp->next != NULL){
			temp = temp->next;
		}
	temp->next = new;
	count++;
	}
	display(head);
}

void add_before(){
	int before;
	node *new, *preptr,*ptr;
	ptr = head;
	new = (node*) malloc(sizeof(node));
	if(new == NULL){
		printf("No Memory");
	}
	else{
		printf("\nThe node you want to add before : ");
		scanf("%d", &before);
		printf("\nEnter the element you want to add at the before %d : ", before);
		scanf("%d", &num);
		new->data = num;
		while( ptr->data != before){
			preptr = ptr;
			ptr = ptr->next;
		}
		new->next = ptr;
		preptr->next =new;
		count++;
	}
	display(head);
}

void add_after(){
	int after;
	node *new, *preptr,*ptr;
	ptr = head;
	new = (node*) malloc(sizeof(node));
	if(new == NULL){
		printf("No Memory");
	}
	
	else{
		printf("\nThe node you want to add after : ");
		scanf("%d", &after);
		while( preptr->data != after){
			preptr = ptr;
			ptr = ptr->next;
		}
		if (preptr->next == NULL){
			printf("\nThe node doesn't exits\n");
		}
		else{
		printf("\nEnter the element you want to add at the after %d : ", after);
		scanf("%d", &num);
		new->data = num;
		
		
		new->next = ptr;
		preptr->next =new;
		count++;
	}
	}
	display(head);
}
void add_pos(){
	int pos;
	int i =1;
	node *new;
	node *preptr = head;
	node *ptr = head;
	new = (node*) malloc(sizeof(node));
	if(new == NULL){
		printf("No Memory");
	}
	else{
		printf("\nEnter the position you want to add the element : ");
		scanf("%d", &pos);
        if(pos == 1){
            add_beg();
        }
        else{
		printf("\nEnter the element you want to add at position %d : ", pos);
		scanf("%d", &num);
		
		new->data = num;
        
		while(i<pos){
			preptr = ptr;
			ptr = ptr->next;
			i++;
		}
		preptr->next = new;
		new->next = ptr;
		count++;
	}
    }
	display(head);
}
void delete_beg(){
	node *temp = head;
	head = head->next;
	free(temp);
	count--;
	display(head);
}

void delete_end(){
	node *ptr = head;
	node *preptr;
	while(ptr->next != 0){
		preptr = ptr;
		ptr = ptr->next;
	}
	preptr->next = NULL;
	free(ptr);
	count--;
	display(head);
}
void delete_after(){
	node *ptr = head;
	node *preptr = head;
	printf("You want to delete the node comes after :");
	scanf("%d", &num);
	while(preptr->data != num){
		preptr = ptr;
		ptr = ptr->next;
	}
	preptr->next = ptr->next;
	free(ptr);
	count--;
	display(head);
	
}

void delete_before(){
	node *ptr = head;
	node *preptr, *temp = head;
	printf("You want to delete the node comes before :");
	scanf("%d", &num);
	while(ptr->data != num){
		preptr = temp;
		temp = temp->next;
		ptr = temp ->next;
	}
    
	preptr->next = ptr;
	free(temp);
	count--;
	display(head);
	
}
void delete_pos(){
	node*ptr =head, *preptr =head;
	int pos;
	printf("Element in the position you want to delete: ");
	scanf("%d", &pos);
	for (int i = 1 ; i < pos; i++){
		preptr = ptr;
		ptr = ptr->next;
	}
	preptr->next =ptr->next;
	free(ptr);
	count--;
	display(head);
}

void search(){
	if(head == NULL){
		printf("No linked list");
	}
	else{
	node *temp = head;
	int find,pos=1,flag;
	printf("search: ");
	scanf("%d", &find);
	while(temp != NULL){
		if(temp->data != find){
			temp = temp->next;
			pos++;
			flag = 1;	
		}
		else{
			flag = 0;
			break;
		}	
	}
	if (flag == 0){
			printf("The element %d exists at position %d", find, pos);
		}
	else{
			printf("The element does not exist in the linked list");
		}
	}
}

int main(){
	int choice;
	printf("\n1.Create\n2.Add at beginning\n3.Add at end\n4.Add after a given node\n5.Add before a given node\n6.Add at specific position\n7.Delete at beginning\n8.Delete at end\n9.Delete after a given node\n10.Delete before a given node\n11.Delete at specific position\n12.Search\n13.Display\n");
	while(1){
		printf("\nEnter your choice : ");
		scanf("%d",&choice);
		switch(choice){
			case 0:
			exit(0);

			case 1:
			create();
			break;

			case 2:
			add_beg();
			break;

			case 3:
			add_end();
			break;

			case 4:
			add_after();
			break;

			case 5:
			add_before();
			break;

			case 6:
			add_pos();
			break;

			case 7:
			delete_beg();
			break;

			case 8:
			delete_end();
			break;

			case 9:
			delete_after();
			break;

			case 10:
			delete_before();
			break;

			case 11:
			delete_pos();
			break;

			case 12:
			search();
			break;

			case 13:
			display(head);
			break;
		}
		}
	}



-------------


CQUEUE ARR

#include<stdio.h>
#include<stdlib.h>
#define N 5
int queue[N];
int front = -1;
int rear =  -1;

void enqueue(int val){
    if(front == -1 && rear == -1){
        front = 0;
        rear = 0;
        queue[rear] = val;
        printf("queue[%d]->%d", rear, queue[rear]);
    }
    else if(front == (rear+1)%N){
        printf("\n f: %d r: %d ",front,rear);
        printf("\nOverflow");

    }
    else{
        rear =  (rear+1) % N;
        queue[rear] = val;
        printf("queue[%d]->%d", rear, queue[rear]);
    }
    
}
void dequeue(){
    if(front == -1 && rear == -1){
        printf("\nUnderflow");
    }
    else{
        printf("f b : %d ", front);
        front = (front + 1) % N;
        printf("f a :%d", front);
    }
}

void display(){
    for(int i = front; i != rear; i = (i+1)%N){
        printf("%d ", queue[i]);
    }
    printf("%d ", queue[rear]);
}

void peek(){
    printf("%d", queue[front]);
}

void isempty(){
    if(front == -1 && rear ==-1 ){
        printf("\nThe queue is empty\n");
    }
    else{
        printf("\nQueue is not empty\n");
    }
}
void isfull(){
    if(front == (rear+1)%N){
        printf("\nQueue is full\n");
    }
    else{
        printf("\nQueue is not full\n");
    }
}

void search(){
    int  find,temp = front,flag = 0;
    if(queue == NULL){
        printf("There's no queue");
    }
    else{
    printf("Value to search : ");
    scanf("%d", &find);
        do{
            {
            
            if(queue[temp] == find){
                flag = 1;
                break;   
        }
        else{
            flag = 0;
        }
        temp = (temp+1) % N;
        }
        }
        while (queue[temp] != rear);
        
        if (flag == 0){
            printf("\n Value %d does not exist in queue\n", find);
        }
        if(flag == 1){
            printf("\n Value %d exists in position %d",find,temp+1);
        }
        
    }
}

int main(){
    int choice;
    int val;
    while(1){
        printf("\n1.Enqueue\n2.Dequeue\n3.Display\n4.Peek\n5.IsEmpty?\n6.IsFull?\n7.Search\n");
        printf("Enter your choice : ");
        scanf("%d",&choice);
        switch (choice)
        {
            case 0:
            exit(0);

            case 1 : 
            if(front == (rear+1)%N){
                printf("\nOverflow");
            }
            else{
            printf("\nElement to enqueue : ");
            scanf("%d",&val);
            enqueue(val);
            }
            break;
            
            case 2:
            dequeue();
            break;

            case 3:
            display();
            break;

            case 4:
            peek();
            break;

             case 5:
            isempty();
            break;

            case 6:
            isfull();
            break;

             case 7:
            search();
            break;
        }
    }
    
}

---------------


CQUEUE DLL

#include <stdio.h>
#include <stdlib.h>

struct node
{
    struct node *prev;
    struct node *next;
    int data;
};

struct node *front;
struct node *rear;

void enqueue(int data)
{
    struct node *newnode = (struct node *)malloc(sizeof(struct node));
    newnode->data = data;
    newnode->next = NULL;
    newnode->prev = NULL;
    if(front==NULL)
    {
        front = newnode;
        rear = newnode;
    }
    else
    {
        rear->next = newnode;
        rear->prev = rear;
        rear = rear->next;
        rear->next = NULL;
    }
}

void dequeue()
{
    if(front==NULL)
    {
        return;
    }
    else
    {
        struct node *temp = front;
        front = front->next;
        front->prev=NULL;
        free(temp);
    }
}

void display()
{
    if(front==NULL)
    {
        printf("\nthe queue is empty\n");
    }
    else
    {
        struct node * temp = front;
        while(temp!=NULL)
        {
            printf("%d\t",temp->data);
            temp = temp->next;
        }
    }
}

void search(int value)                                       
{
    int flag=0,count=0;
    struct node *temp = front;
    while(temp!=NULL)
    {
        if(temp->data==value)
        {
            flag=1;
            break;
        }
        temp =temp->next;
        count++;
    }
    if(flag==0)
        printf("\nvalue was not found");
    else
    {
        printf("value was found at location %d",count);
    }
}

void peek(){
    printf("Front %d",front->data);
}

int main()
{
    int choice,value;
    while(choice!=6)
    {
        printf("\nEnter your choice:");
        printf("\n1.To enter data into the queue");
        printf("\n2.To remove data from the queue");
        printf("\n3.To display all the elements in the queue");
        printf("\n4.To search for an element");
        printf("\n5.To diplay the peek element");
        printf("\n6.To quit the program");
        printf("\n");
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:
            printf("\nenter the value which you want to insert:");
            scanf("%d",&value);
            enqueue(value);
            break;
            case 2:
            dequeue();
            break;
            case 3:
            display();
            break;
            case 4:
            printf("\nenter the value which you want tot search for:");
            scanf("%d",&value);
            search(value);
            break;
            case 5:
            peek();
            break;
            
        }
    }
    return 0;
}

-----------

CQUEUE LL

#include<stdio.h>
#include<stdlib.h>

typedef struct queue {
    struct queue *prev;
    int data;
    struct queue *next;
}queue;

queue *front = NULL;
queue *rear = NULL;

void enqueue(int val){
    queue *newnode;
    newnode = (queue*) malloc(sizeof(queue));
    newnode->prev = NULL;
    newnode->data = val;
    newnode->next = NULL;
    if(front == NULL && rear == NULL){
        front = newnode;
        rear = newnode;
    }
    else{
        newnode->prev = rear;
        rear->next = newnode;
        rear = newnode;
        
    }
}

void dequeue(){
    if(front == NULL && rear == NULL){
        printf("No value to dequeue");
    }
    else{
    queue *temp = front;
    front = front->next;
    front->prev = rear;
    free(temp);
    }
}

void display(){
    queue *temp = front;
    while(temp!= NULL){
        printf("%d ",temp->data);
        temp = temp->next;
    }
}

void peek(){
    printf("Front : %d", front->data);
}

void search(){
    if (front == NULL){
        printf("There's no queue to search");
    }
    else{
    queue *temp = front;
    int find,pos = 1, flag = 0 ;
    printf("Value to search : ");
    scanf("%d", &find);
while (temp->next != front)
    {
        if(temp->data != find){
        temp = temp->next;
        pos++;
        flag = 0;
        }
        if(temp->data == find){
            flag = 1;
            break;
        }
    }
     if(flag == 1 ){
            printf("\n Value %d exists at position %d",find, pos);
        }
    if(flag == 0){
            printf("\n Value %d does not exist\n",find);
        }
    }
}

int main(){
    int choice,val;
    while ((1))
    {
        printf("\n0.Exit\n1.Enqueue\n2.Dequeue\n3.Display\n4.Peek\n5.Search\n");
        printf("\nEnter your choice : ");
        scanf("%d", &choice);
        switch (choice)
        {
        case 0:
            exit(0);
        
        case 1:
            printf("\nEnter the value to enqueue: ");
            scanf("%d", &val);
            enqueue(val);
            break;

        case 2:
            dequeue();
            break;

        case 3:
            display();
            break;

        case 4:
            peek();
            break;
        
        case 5:
            search();
            break;
        }
    }
    
}

--------------
BSTREE

#include <stdio.h>
#include <stdlib.h>
struct node {
  int key;
  struct node *left, *right;
};

struct node *newNode(int item) {
  struct node *temp = (struct node *)malloc(sizeof(struct node));
  temp->key = item;
  temp->left = temp->right = NULL;
  return temp;
}
void inorder(struct node *root) {
  if (root != NULL) {
    inorder(root->left);
    printf("%d -> ", root->key);
    inorder(root->right);
  }
}
void preorder(struct node *root) {
  if (root != NULL) {
    printf("%d -> ", root->key);
    preorder(root->left);
    preorder(root->right);
  }
}
void postorder(struct node *root) {
  if (root != NULL) {
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->key);
  }
}
struct node *insert(struct node *node, int key) {
  
  if (node == NULL) return newNode(key);
 
  if (key < node->key)
    node->left = insert(node->left, key);
  else
    node->right = insert(node->right, key);

  return node;
}

// Find the inorder successor
struct node *minValueNode(struct node *node) {
  struct node *current = node;

  // Find the leftmost leaf
  while (current && current->left != NULL)
    current = current->left;

  return current;
}

struct node *deleteNode(struct node *root, int key) {
  
  if (root == NULL) return root;

  
  if (key < root->key)
    root->left = deleteNode(root->left, key);
  else if (key > root->key)
    root->right = deleteNode(root->right, key);

  else {
    // If the node is with only one child or no child
    if (root->left == NULL) {
      struct node *temp = root->right;
      free(root);
      return temp;
    } else if (root->right == NULL) {
      struct node *temp = root->left;
      free(root);
      return temp;
    }

    // If the node has two children
    struct node *temp = minValueNode(root->right);

    // Place the inorder successor in position of the node to be deleted
    root->key = temp->key;

    // Delete the inorder successor
    root->right = deleteNode(root->right, temp->key);
  }
  return root;
}

int search(struct node* root, int value) 
{ 
  
    while (root != NULL){

        if (value > root->key) 
            root = root->right; 

        else if (value < root->key) 
            root = root->left; 
        else
            return 1; 
    } 
    return 0; 
} 

int main() {
  int i,n,val,dval,choice,item;
  struct node *root = NULL;

 do      
        {  
            printf("\nBinary Search Tree Operations");  
            printf("\n1. To insert a new node in the Binary Tree");  
            printf("\n2. To delete a value from tree");  
            printf("\n3. To search the node in tree");
            printf("\n4. To display the elements in inorder traversal");
            printf("\n5. To display the elements in preorder traversal");
            printf("\n6. To display the elements in postorder traversal");
            printf("\nEnter your choice:");
 
            scanf("%d",&choice);              
            switch (choice)  
            {  
            case 1 :   
                printf("Enter the number of elements to add: ");
                scanf("%d",&n);
                for(i=0;i<n;i++)
                {
                scanf("%d",&val);
                root = insert(root, val);
                }                   
                break;                            
            case 2 :   
                printf("Enter an element to delete: ");
                scanf("%d",&dval);
                root = deleteNode(root, dval); 
                break; 
            case 3 :   
                
                printf("Enter an item to search: ");
                scanf("%d" ,&item);
                int found = search(root,item);

                if(found)
                    printf("%d value is found in the tree\t",item);
                else
                    printf("%d value not found in the tree\t",item);

            case 4 :   
                printf("Inorder traversal: ");
                inorder(root); 
                break; 
                 case 5 :   
                printf("preorder traversal: ");
                preorder(root); 
                break; 
                 case 6 :   
                printf("postorder traversal: ");
                postorder(root); 
                break; 
            default :   
                printf("Wrong Entry\n");  
                break;     
            }  
  
            printf("\nDo you want to continue (Type y or n)\n");  
            scanf(" %c",&choice);                          
        } while (choice == 'Y'|| choice == 'y');  
  
   return 0;  

}


-------------

DHASH

#include <stdio.h>
#include <stdlib.h>
#define n 10
int hash[n] = {NULL};
void insert(){
    int hash2,value,i,hashkey,index;
    printf("enter the value : ");
    scanf("%d",&value);
    hash2 = 7-(value%7);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i*hash2)%n;
        if(hash[index] == NULL){
            hash[index] = value;
            break;
        }
    }
    if(i == n){
        printf("table size if full");
    }
}
void delete(){
    int value,i,hashkey,index,hash2;
    printf("enter the value : ");
    scanf("%d",&value);
    hash2 = 7-(value%7);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i*hash2)%n;
        if(hash[index] == value){
            hash[index] = -1;
            break;
        }
    }
}
void display(){
    int i;
    for(i=0;i<n;i++){
        printf("key = %d and value = %d\n",i,hash[i]);
    }
}
void search(){
    int value,i,hash2,hashkey,index,flag = 0;
    printf("enter the value : ");
    scanf("%d",&value);
    hash2 = 7-(value%7);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i)%n;
        if(hash[index] == value){
            flag = 1;
            break;
        }
    }
    if(flag == 1){
        printf("element is found at key %d\n",index);
    }else{
        printf("element not found");
    }
}

int main(){
    int choice;
    while(1){
        printf("enter 1 to insert\n");
        printf("enter 2 to delete\n");
        printf("enter 3 to display\n");
        printf("enter 4 to search\n");
        printf("enter the choice : ");
        scanf("%d",&choice);
        switch(choice){
            case 1:
            insert();
            break;
            case 2:
            delete();
            break;
            case 3:
            display();
            break;
            case 4:
            search();
            break;
            default:
            printf("wrong choice");
        }
    }
}


----------------

LHASH

#include <stdio.h>
#include <stdlib.h>
#define n 10
int hash[n] = {NULL};
void insert(){
    int value,i,hashkey,index;
    printf("enter the value : ");
    scanf("%d",&value);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i)%n;
        if(hash[index] == NULL){
            hash[index] = value;
            break;
        }
    }
    if(i == n){
        printf("table size if full");
    }
}
void delete(){
    int value,i,hashkey,index;
    printf("enter the value : ");
    scanf("%d",&value);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i)%n;
        if(hash[index] == value){
            hash[index] = -1;
            break;
        }
    }
}
void display(){
    int i;
    for(i=0;i<n;i++){
        printf("key = %d and value = %d\n",i,hash[i]);
    }
}
void search(){
    int value,i,hashkey,index,flag = 0;
    printf("enter the value : ");
    scanf("%d",&value);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i)%n;
        if(hash[index] == value){
            flag = 1;
            break;
        }
    }
    if(flag == 1){
        printf("element is found at key %d\n",index);
    }else{
        printf("element not found");
    }
}

int main(){
    int choice;
    while(1){
        printf("1.Insert\n");
        printf("2.Delete\n");
        printf("3.Display\n");
        printf("4.Search\n");
        printf("Enter the  Choice : ");
        scanf("%d",&choice);
        switch(choice){
            case 1:
            insert();
            break;
            case 2:
            delete();
            break;
            case 3:
            display();
            break;
            case 4:
            search();
            break;
            default:
            printf("wrong choice");
        }
    }
}


---------------

QHASH

#include <stdio.h>
#include <stdlib.h>
#define n 10
int hash[n] = {NULL};
void insert(){
    int value,i,hashkey,index;
    printf("enter the value : ");
    scanf("%d",&value);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i*i)%n;
        if(hash[index] == NULL){
            hash[index] = value;
            break;
        }
    }
    if(i == n){
        printf("table size if full");
    }
}
void delete(){
    int value,i,hashkey,index;
    printf("enter the value : ");
    scanf("%d",&value);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i*i)%n;
        if(hash[index] == value){
            hash[index] = -1;
            break;
        }
    }
}
void display(){
    int i;
    for(i=0;i<n;i++){
        printf("key = %d and value = %d\n",i,hash[i]);
    }
}
void search(){
    int value,i,hashkey,index,flag = 0;
    printf("enter the value : ");
    scanf("%d",&value);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i*i)%n;
        if(hash[index] == value){
            flag = 1;
            break;
        }
    }
    if(flag == 1){
        printf("element is found at key %d\n",index);
    }else{
        printf("element not found");
    }
}

int main(){
    int choice;
    while(1){
        printf("1.Insert\n");
        printf("2.Delete\n");
        printf("3.Display\n");
        printf("4.Search\n");
        printf("Enter the choice : ");
        scanf("%d",&choice);
        switch(choice){
            case 1:
            insert();
            break;
            case 2:
            delete();
            break;
            case 3:
            display();
            break;
            case 4:
            search();
            break;
            default:
            printf("wrong choice");
        }
    }
}


-------------


RHASH

#include <stdio.h>
#include <stdlib.h>
#define n 5

int hash[n] = {};
int rhash[2*n] = {};
int flag=0;

int prime(int num)
{
    int i,j;
    for(i=num+1;;i++)
    {
        for(j=2;j<i;j++)
        {
            if(i%j==0)
                break;
        }
        if(j==i)
        {
            return i;
        }
    }
}

int count(){
    int i, counter=0;
    for(i=0;i<n;i++){
        if (hash[i]!=0 && hash[i]!=-1)
        {
            counter+=1;
        }
    }
    return counter;
}

void insert(){
    int value,hashkey,index,rhashkey;
    int p = prime(2*n);
    printf("\nEnter a value : ");
    scanf("%d",&value);

    if (count()>n-1)
    {
        if (flag==0)
        {
            flag=1;
            printf("\nInner count==n.SO . . .");
            int nvalue,i,k;
            for ( i = 0; i < n; i++)
            {
                nvalue = hash[i];
                for(int j=0;j<2*n;j++){
                    rhashkey = nvalue%p;
                    index = (rhashkey+j)%p;
                    if(rhash[index] == 0 || rhash[index] == -1){
                        rhash[index] = nvalue;
                        break;
                    }
                }
            }
            for ( k = 0; k < 2*n; k++)
            {
                rhashkey = value%p;
                index = (rhashkey+k)%p;
                if(rhash[index] == 0 || rhash[index] == -1){
                    rhash[index] = value;
                    break;
                }
            }
        }
        else
        {
            int i;
            for ( i = 0; i < 2*n; i++)
            {
                rhashkey = value%p;
                index = (rhashkey+i)%p;
                if(rhash[index] == 0 || rhash[index] == -1){
                    rhash[index] = value;
                    break;
                }
            }
            if(i == 2*n){
                printf("\nTable if full\n");
            }
        }
    }
    else if (count()<n)
    {
        int i;
        for(i=0;i<n;i++){
            hashkey = value%n;
            index = (hashkey+i)%n;
            if(hash[index] == 0 || hash[index] == -1){
                hash[index] = value;
                break;
            }
        }
    }
}
void delete(){
    int value,i,hashkey,index,rhashkey;
    printf("\nEnter a value : ");
    scanf("%d",&value);
    if (flag==0)
    {
        hashkey = value%n;
        for(i=0;i<n;i++){
            index = (hashkey+i)%n;
            if(hash[index] == value){
                hash[index] = -1;
                printf("\nElement deleted successfully\n");
                break;
            }
        }
    }
    else
    {
        int i;
        int p = prime(2*n);
        rhashkey = value%p;
        for ( i = 0; i < 2*n; i++)
        {
            index = (rhashkey+i)%p;
            if(rhash[index] == value){
                rhash[index] = -1;
                printf("\nElement deleted successfully\n");
                break;
            }
        }
    }
    
}
void display(){
    int i;
    if (flag==1)
    {
        for(i=0;i<(2*n);i++){
        printf("key = %d and value = %d\n",i,rhash[i]);
        }
    }
    else if (flag==0)
    {
        for(i=0;i<n;i++){
        printf("key = %d and value = %d\n",i,hash[i]);
        }
    }
}

void search(){
    int value,i,hashkey,index,flag = 0;
    printf("\nEnter a value : ");
    scanf("%d",&value);
    hashkey = value%n;
    for(i=0;i<n;i++){
        index = (hashkey+i)%n;
        if(hash[index] == value){
            flag = 1;
            break;
        }
    }
    if(flag == 1){
        printf("Element is found at key %d\n",index);
    }else{
        printf("\nElement not found\n");
    }
}

int main(){
    int choice;
    while(1){
        printf("REHASHING\n");
        printf("1.INSERT\n");
        printf("2.DELETE\n");
        printf("3.DISPLAY\n");
        printf("4.SEARCH\n");
        printf("5.EXIT\n");

        printf("Enter your choice : ");
        scanf("%d",&choice);
        switch(choice){
            case 1:
            insert();
            break;
            case 2:
            delete();
            break;
            case 3:
            display();
            break;
            case 4:
            search();
            break;
            case 5:
            exit(0);
            break;
            default:
            printf("\nWrong choice. Try again.");
        }
    }
}


-----------

SCHAR ARR

#include <stdio.h>
#include <stdlib.h>
#include<ctype.h>
#define size 5
int top=-1;
char arr[size];

void push();
void pop();
void occur();
void show();

void main()
{
    int choice;
    while(choice!=5)
    {
        printf("\n");
        printf("\nStack Operations");
        printf("\n1.Push the element (Only Characters alowed!!!)");
        printf("\n2.Pop the element");
        printf("\n3.Find no of occurence");
        printf("\n4.Show");
        printf("\n5.Exit");
        printf("\nEnter the choice :");
        scanf("%d",&choice);

        switch(choice){
            case 1:
            push();
            break;

            case 2:
            pop();
            break;

            case 3:
            occur();
            break;

            case 4:
            show();
            break;

            case 5:
            exit(0);

            default:
            printf("\nTnvalid Choice !!!");

        }
    }
}

void push()
{
	char c;
	
	if(top==size-1)
	{
		printf("\nOverflow!!");
	}
	else
	{
		printf("\nEnter element to be inserted to the stack:");
		scanf("%s",&c);

		if (isalpha(c) == 0)
   		{
       	printf("Only Characters are allowed");
   		}
   		else{
		if (c ==arr[top]){
			printf("Cant push the element , the previos element is same(repitaion not allowed)");
		}
		else{
		top=top+1;
		arr[top]=c;
		}
       	
   		}

		
	}
}

void pop()
{
	if(top==-1)
	{
		printf("\nUnderflow!!");
	}
	else
	{
		printf("\nPopped element:  %c",arr[top]);
		top=top-1;
	}
}

void occur(){
    int i,count=0;
    char find;
	if(top==-1)
	{
		printf("\nUnderflow!!");
	}
	else
	{
		printf("Enter the element to find the number of occurance :");
		scanf("%s",&find);
		
		for(i=0;i<=top;i++)
		{
			if(arr[i]==find)
			{
                count = count+1;
				
			}
			else if(i==top)
			{
				printf("element not found");
			}
			
		}
        printf("\nThe number of occurance of %c is %d",find,count);
		
	}
}

void show(){

    if(top==-1)
	{
		printf("\nUnderflow!!");
	}
	else
	{
		printf("\nElements present in the stack: \n");
		for(int i=top;i>=0;--i){

			printf("%c\n",arr[i]);
		}
	}
}



--------

