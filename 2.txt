AVL.C

// AVL tree implementation in C

#include <stdio.h>
#include <stdlib.h>

// Create Node
struct Node {
  int key;
  struct Node *left;
  struct Node *right;
  int height;
};

int max(int a, int b);

// Calculate height
int height(struct Node *N) {
  if (N == NULL)
    return 0;
  return N->height;
}

int max(int a, int b) {
  return (a > b) ? a : b;
}

// Create a node
struct Node *newNode(int key) {
  struct Node *node = (struct Node *)
    malloc(sizeof(struct Node));
  node->key = key;
  node->left = NULL;
  node->right = NULL;
  node->height = 1;
  return (node);
}

// Right rotate
struct Node *rightRotate(struct Node *y) {
  struct Node *x = y->left;
  struct Node *T2 = x->right;

  x->right = y;
  y->left = T2;

  y->height = max(height(y->left), height(y->right)) + 1;
  x->height = max(height(x->left), height(x->right)) + 1;

  return x;
}

// Left rotate
struct Node *leftRotate(struct Node *x) {
  struct Node *y = x->right;
  struct Node *T2 = y->left;

  y->left = x;
  x->right = T2;

  x->height = max(height(x->left), height(x->right)) + 1;
  y->height = max(height(y->left), height(y->right)) + 1;

  return y;
}

// Get the balance factor
int getBalance(struct Node *N) {
  if (N == NULL)
    return 0;
  return height(N->left) - height(N->right);
}

// Insert node
struct Node *insertNode(struct Node *node, int key) {
  // Find the correct position to insertNode the node and insertNode it
  if (node == NULL)
    return (newNode(key));

  if (key < node->key)
    node->left = insertNode(node->left, key);
  else if (key > node->key)
    node->right = insertNode(node->right, key);
  else
    return node;

  // Update the balance factor of each node and
  // Balance the tree
  node->height = 1 + max(height(node->left),
               height(node->right));

  int balance = getBalance(node);
  if (balance > 1 && key < node->left->key)
    return rightRotate(node);

  if (balance < -1 && key > node->right->key)
    return leftRotate(node);

  if (balance > 1 && key > node->left->key) {
    node->left = leftRotate(node->left);
    return rightRotate(node);
  }

  if (balance < -1 && key < node->right->key) {
    node->right = rightRotate(node->right);
    return leftRotate(node);
  }

  return node;
}

struct Node *minValueNode(struct Node *node) {
  struct Node *current = node;

  while (current->left != NULL)
    current = current->left;

  return current;
}

// Delete a nodes
struct Node *deleteNode(struct Node *root, int key) {
  // Find the node and delete it
  if (root == NULL)
    return root;

  if (key < root->key)
    root->left = deleteNode(root->left, key);

  else if (key > root->key)
    root->right = deleteNode(root->right, key);

  else {
    if ((root->left == NULL) || (root->right == NULL)) {
      struct Node *temp = root->left ? root->left : root->right;

      if (temp == NULL) {
        temp = root;
        root = NULL;
      } else
        *root = *temp;
      free(temp);
    } else {
      struct Node *temp = minValueNode(root->right);

      root->key = temp->key;

      root->right = deleteNode(root->right, temp->key);
    }
  }

  if (root == NULL)
    return root;

  // Update the balance factor of each node and
  // balance the tree
  root->height = 1 + max(height(root->left),
               height(root->right));

  int balance = getBalance(root);
  if (balance > 1 && getBalance(root->left) >= 0)
    return rightRotate(root);

  if (balance > 1 && getBalance(root->left) < 0) {
    root->left = leftRotate(root->left);
    return rightRotate(root);
  }

  if (balance < -1 && getBalance(root->right) <= 0)
    return leftRotate(root);

  if (balance < -1 && getBalance(root->right) > 0) {
    root->right = rightRotate(root->right);
    return leftRotate(root);
  }

  return root;
}

// Print the tree
void printPreOrder(struct Node *root) {
  if (root != NULL) {
    printf("%d ", root->key);
    printPreOrder(root->left);
    printPreOrder(root->right);
  }
}

int main() {
  struct Node *root = NULL;

  root = insertNode(root, 2);
  root = insertNode(root, 1);
  root = insertNode(root, 7);
  root = insertNode(root, 4);
  root = insertNode(root, 5);
  root = insertNode(root, 3);
  root = insertNode(root, 8);

  printPreOrder(root);

  root = deleteNode(root, 3);

  printf("\nAfter deletion: ");
  printPreOrder(root);

  return 0;
}



-------------------------

AVL1.C

#include<stdio.h>
#include<stdlib.h>
#define GAP 1
struct node
{
	int data,height;
	struct node *left,*right; 
}*root=0,*newnode,*temp,*temp1,*temp2;
max(int a,int b)
{
	return (a>b)?a:b;
}
height(struct node *root)
{
	return (root==0)?0:root->height;
}
balancefactor(struct node *root)
{
	return (root==0)?0:height(root->left)-height(root->right);
}
struct node *leftrotate(struct node *root)
{
    temp1=root->right;
    temp2=temp1->left;
    temp1->left=root;
    root->right=temp2;
    root->height=1+max(height(root->left),height(root->right));
    temp1->height=1+max(height(temp1->left),height(temp1->right));
    return temp1;
}
struct node *rightrotate(struct node *root)
{
    temp1=root->left;
    temp2=temp1->right;
    temp1->right=root;
    root->left=temp2;
    root->height=1+max(height(root->left),height(root->right));
    temp1->height=1+max(height(temp1->left),height(temp1->right));
    return temp1;
}
struct node *minimum(struct node *root)
{
	return ((root==0)||(root->left==0))?root:minimum(root->left);
}
struct node *maximum(struct node *root)
{
	return ((root==0)||(root->right==0))?root:maximum(root->right);
}
struct node *search(struct node *root,int value)
{
	if((root==0)||(root->data==value))
		return root;
	else 
		return (value<root->data)?search(root->left,value):search(root->right,value);
}
count(struct node *root)
{
	return (root==0)?0:count(root->left)+count(root->right)+1;
}
struct node *insertnode(struct node *root,int value)
{
	int bf;
	if(root==0)
	{
		newnode=(struct node*)malloc(sizeof(struct node));
		newnode->data=value;
		newnode->height=1;
		newnode->left=newnode->right=0;
		return newnode;
	}
	if(value<root->data)
		root->left=insertnode(root->left,value);
	else if(value>root->data)
		root->right=insertnode(root->right,value);
	else
		return root;
	root->height=1+max(height(root->left),height(root->right));	
	bf=balancefactor(root);
	if(bf>1&&value<root->left->data)
        return rightrotate(root);
    if(bf<-1&&value>root->right->data)
        return leftrotate(root);
    if(bf>1&&value>root->left->data)
    {
        root->left=leftrotate(root->left);
        return rightrotate(root);
    }
    if(bf<-1&&value<root->right->data)
    {
        root->right=rightrotate(root->right);
        return leftrotate(root);
    }
    return root;
}
struct node *deletenode(struct node *root,int value)
{
	int bf,ch;
	if(root==0)
		return root;
	if(value<root->data)
		root->left=deletenode(root->left,value);
	else if(value>root->data)
		root->right=deletenode(root->right,value);
	else
	{
		if(root->left==0)
		{
			temp=root;
			root=root->right;
			free(temp);
		}
		else if(root->right==0)
		{
			temp=root;
			root=root->left;
			free(temp);
		}
		else
		{
			printf("Replace with 1.Inorder predecessor or 2.Inorder successor");
			printf("\nEnter your choice: ");
			scanf("%d",&ch);
			if(ch==1)
			{
				temp=maximum(root->left);
    			root->data=temp->data;
		    	root->left=deletenode(root->left,temp->data);
			}
			else
			{
				temp=minimum(root->right);
    			root->data=temp->data;
		    	root->right=deletenode(root->right,temp->data);
  			}
  		}
  	}
  	if(root==0)
  		return root;
  	root->height=1+max(height(root->left),height(root->right));	
	bf=balancefactor(root);
	if(bf>1&&balancefactor(root->left)>=0)
        return rightrotate(root);
    if(bf<-1&&balancefactor(root->right)<=0)
        return leftrotate(root);
    if(bf>1&&balancefactor(root->left)<0)
    {
        root->left=leftrotate(root->left);
        return rightrotate(root);
    }
    if(bf<-1&&balancefactor(root->right)>0)
    {
        root->right=rightrotate(root->right);
        return leftrotate(root);
    }
    return root;
}	
void display(struct node *root,int space)
{
	int i;
    if(root==0)
        return;
    space=space+GAP;
    display(root->right,space);
    for(i=GAP;i<space;i++)
        printf("\t");
    printf("%d\n",root->data);
    display(root->left,space);
}
main()
{
	int choice,value;
	printf("AVL Tree Implementation");
	printf("\n1.Insert node\t2.Delete node\t3.Search\t4.Display\t5.Count\t6.End");
	do
	{
		printf("\nEnter your choice: ");
		scanf("%d",&choice);
		switch(choice)
		{
			case 1:	printf("Enter Node: ");
					scanf("%d",&value);
					root=insertnode(root,value);
					printf("Node Inserted\n");
					display(root,0);
					break;
			case 2: if(root==0)
						printf("Tree is Empty");
					else
					{
						printf("Enter Node: ");
						scanf("%d",&value);
						temp=search(root,value);
						if(temp==0)
							printf("Node is not in Tree");
						else
							{
								root=deletenode(root,value);
								printf("Node Deleted");
							}
					}
					break;
			case 3: if(root==0)
						printf("Tree is Empty");
					else
					{
						printf("Enter Node: ");
						scanf("%d",&value);
						temp=search(root,value);
						if(temp==0)
							printf("Node is not in Tree");
						else
							printf("Node is found in location %u",temp);
					}
					break;
			case 4: if(root==0)
						printf("Tree is Empty");
					else
						display(root,0);
					break;
			case 5: printf("No of Nodes in Tree is %d",count(root));
					break;
			case 6: printf("Thank You");
					break;
			default:printf("Invalid Choice");
					break;
		}
	}while(choice!=6);
}

-----------------


AVLTREE.C

#include<stdio.h>
#include<stdlib.h>
#define GAP 1
struct node
{
	int data,height;
	struct node *left,*right; 
}*root=0,*newnode,*temp,*temp1,*temp2;
max(int a,int b)
{
	return (a>b)?a:b;
}
height(struct node *root)
{
	return (root==0)?0:root->height;
}
balancefactor(struct node *root)
{
	return (root==0)?0:height(root->left)-height(root->right);
}
struct node *leftrotate(struct node *root)
{
    temp1=root->right;
    temp2=temp1->left;
    temp1->left=root;
    root->right=temp2;
    root->height=1+max(height(root->left),height(root->right));
    temp1->height=1+max(height(temp1->left),height(temp1->right));
    return temp1;
}
struct node *rightrotate(struct node *root)
{
    temp1=root->left;
    temp2=temp1->right;
    temp1->right=root;
    root->left=temp2;
    root->height=1+max(height(root->left),height(root->right));
    temp1->height=1+max(height(temp1->left),height(temp1->right));
    return temp1;
}
struct node *minimum(struct node *root)
{
	return ((root==0)||(root->left==0))?root:minimum(root->left);
}
struct node *maximum(struct node *root)
{
	return ((root==0)||(root->right==0))?root:maximum(root->right);
}
struct node *search(struct node *root,int value)
{
	if((root==0)||(root->data==value))
		return root;
	else 
		return (value<root->data)?search(root->left,value):search(root->right,value);
}
count(struct node *root)
{
	return (root==0)?0:count(root->left)+count(root->right)+1;
}
struct node *insertnode(struct node *root,int value)
{
	int bf;
	if(root==0)
	{
		newnode=(struct node*)malloc(sizeof(struct node));
		newnode->data=value;
		newnode->height=1;
		newnode->left=newnode->right=0;
		return newnode;
	}
	if(value<root->data)
		root->left=insertnode(root->left,value);
	else if(value>root->data)
		root->right=insertnode(root->right,value);
	else
		return root;
	root->height=1+max(height(root->left),height(root->right));	
	bf=balancefactor(root);
	if(bf>1&&value<root->left->data)
        return rightrotate(root);
    if(bf<-1&&value>root->right->data)
        return leftrotate(root);
    if(bf>1&&value>root->left->data)
    {
        root->left=leftrotate(root->left);
        return rightrotate(root);
    }
    if(bf<-1&&value<root->right->data)
    {
        root->right=rightrotate(root->right);
        return leftrotate(root);
    }
    return root;
}
struct node *deletenode(struct node *root,int value)
{
	int bf,ch;
	if(root==0)
		return root;
	if(value<root->data)
		root->left=deletenode(root->left,value);
	else if(value>root->data)
		root->right=deletenode(root->right,value);
	else
	{
		if(root->left==0)
		{
			temp=root;
			root=root->right;
			free(temp);
		}
		else if(root->right==0)
		{
			temp=root;
			root=root->left;
			free(temp);
		}
		else
		{
			printf("Replace with 1.Inorder predecessor or 2.Inorder successor");
			printf("\nEnter your choice: ");
			scanf("%d",&ch);
			if(ch==1)
			{
				temp=maximum(root->left);
    			root->data=temp->data;
		    	root->left=deletenode(root->left,temp->data);
			}
			else
			{
				temp=minimum(root->right);
    			root->data=temp->data;
		    	root->right=deletenode(root->right,temp->data);
  			}
  		}
  	}
  	if(root==0)
  		return root;
  	root->height=1+max(height(root->left),height(root->right));	
	bf=balancefactor(root);
	if(bf>1&&balancefactor(root->left)>=0)
        return rightrotate(root);
    if(bf<-1&&balancefactor(root->right)<=0)
        return leftrotate(root);
    if(bf>1&&balancefactor(root->left)<0)
    {
        root->left=leftrotate(root->left);
        return rightrotate(root);
    }
    if(bf<-1&&balancefactor(root->right)>0)
    {
        root->right=rightrotate(root->right);
        return leftrotate(root);
    }
    return root;
}	
void display(struct node *root,int space)
{
	int i;
    if(root==0)
        return;
    space=space+GAP;
    display(root->right,space);
    for(i=GAP;i<space;i++)
        printf("\t");
    printf("%d\n",root->data);
    display(root->left,space);
}
main()
{
	int choice,value;
	printf("AVL Tree Implementation");
	printf("\n1.Insert node\t2.Delete node\t3.Search\t4.Display\t5.Count\t6.End");
	do
	{
		printf("\nEnter your choice: ");
		scanf("%d",&choice);
		switch(choice)
		{
			case 1:	printf("Enter Node: ");
					scanf("%d",&value);
					root=insertnode(root,value);
					printf("Node Inserted\n");
					display(root,0);
					break;
			case 2: if(root==0)
						printf("Tree is Empty");
					else
					{
						printf("Enter Node: ");
						scanf("%d",&value);
						temp=search(root,value);
						if(temp==0)
							printf("Node is not in Tree");
						else
							{
								root=deletenode(root,value);
								printf("Node Deleted");
							}
					}
					break;
			case 3: if(root==0)
						printf("Tree is Empty");
					else
					{
						printf("Enter Node: ");
						scanf("%d",&value);
						temp=search(root,value);
						if(temp==0)
							printf("Node is not in Tree");
						else
							printf("Node is found in location %u",temp);
					}
					break;
			case 4: if(root==0)
						printf("Tree is Empty");
					else
						display(root,0);
					break;
			case 5: printf("No of Nodes in Tree is %d",count(root));
					break;
			case 6: printf("Thank You");
					break;
			default:printf("Invalid Choice");
					break;
		}
	}while(choice!=6);
}


-------------------------
BST.C

#include <stdio.h>
#include <stdlib.h>

struct node{
    int data;
    struct node *left,*right;
}*root=0,*newnode,*temp;
struct node *min(struct node *root){
    if (root->left==0) return root;
    else
    return min(root->left);
}                      

struct node* insert(struct node *root,int val){
    if (root==0)
        {
            newnode = (struct node*)malloc(sizeof(struct node));
            newnode->data=val;
            newnode->left=newnode->right=0;
            return newnode;
        }
    else if (val<root->data)
        root->left=insert(root->left,val);
    else
        root->right=insert(root->right,val);
        return root;
}

struct node* delete(struct node *root,int val){
    if (val<root->data)
        root->left=delete(root->left,val);
    else if (val>root->data)
        root->right=delete(root->right,val);
    else{
            if (root->left==0 && root->right==0){
                free(root);
                root=0;
            }
            else if(root->left==0 || root->right==0){
                if (root->left==0){
                temp = root->right;
                free(root);
                return temp;}
                else{
                temp = root->left;
                free(root);
                return temp;}}
            else{
                printf("two child");
                temp=min(root->right);
                root->data=temp->data;
                root->right=delete(root->right,temp->data);}
    }
    return root;
}

void inorder(struct node *root){
    if (root==0)
        return;
    inorder(root->left);
    printf("%d\t",root->data);
    inorder(root->right);
}

void postorder(struct node *root)
{
    if (root==0)
        return;
    postorder(root->left);
    postorder(root->right);
    printf("%d\t",root->data);
}
void preorder(struct node *root)
{
    if (root==0)
        return;
    printf("%d\t",root->data);
    preorder(root->left);
    preorder(root->right);
}
void display(struct node *root,int space){
    if (root==0) return;
    space+=1;
    display(root->right,space);
    for(int i=1;i<space;i++)
        printf("\t");
    printf("%d\n",root->data);
    display(root->left,space);
}

struct node *max(struct node *root){
    if (root->right==0) return root;
    else
    return max(root->right);
}



int main() {
    int ch,val;
        root=insert(root,50);
        root=insert(root,25);
        root=insert(root,75);
        root=insert(root,15);
        root=insert(root,35);
        root=insert(root,65);
        root=insert(root,90);
        root=insert(root,100);
        root=insert(root,80);
        root=insert(root,55);
        root=insert(root,30);
        root=insert(root,36);
        root=insert(root,16);
        root=insert(root,14);
        root=insert(root,66);
        printf("\nInorder\n");
        inorder(root);
        printf("\nPostorder\n");
        postorder(root);
        printf("\nPreorder\n");
        preorder(root);
        printf("\nDisplay as tree\n");
        display(root,0);
        // root=delete(root,14);
        // printf("\nDisplay as tree\n");
        // display(root,0);
        // root=delete(root,100);
        // printf("\nDisplay as tree\n");
        // display(root,0);
        // root=delete(root,90);
        // printf("\nDisplay as tree\n");
        // display(root,0);
        // root=delete(root,15);
        // printf("\nDisplay as tree\n");
        // display(root,0);
        // root=delete(root,25);
        // printf("\nDisplay as tree\n");
        // display(root,0);
        printf("\n1.Insert\t2.Min and Max\t11.Inorder,Postorder,Preorder, Display\t\n");
    while(1){
        printf("\nEnter your Choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1:
            printf("Enter Value: ");
            scanf("%d",&val);
            root=insert(root,val);
            break;
            case 2:
            if (root==0)
            printf("\nTree is empty\n");
            else
            printf("The minimum data is %d\n",(min(root)->data));
            printf("The maximum data is %d\n",(max(root)->data));
            break;
            case 11:
            {
                if(root==0)
                printf("\nTree is Empty\n");
                else
                printf("\nInorder\n");
                inorder(root);
                printf("\nPostorder\n");
                postorder(root);
                printf("\nPreorder\n");
                preorder(root);
                printf("\nDisplay Tree\n");
                display(root,0);
                break;
            }
        }
    }
}

-------------------------

BSTSSSSS.C

/*
* C program to implement the Binary Search Tree 
*/
#include <stdio.h>
#include <stdlib.h>
 
// structure of a node
struct node
{
    int data;
    struct node *left;
    struct node *right;
};
 
// globally initialized root pointer
struct node *root = NULL;
 
// function prototyping
struct node *create_node(int);
void insert(int);
struct node *delete (struct node *, int);
int search(int);
void inorder(struct node *);
void postorder(struct node *);
void preorder(struct node *);
struct node *smallest_node(struct node *);
struct node *largest_node(struct node *);
int get_data();
 
int main()
{
    int userChoice;
    int userActive = 'Y';
    int data;
    struct node* result = NULL;
 
    while (userActive == 'Y' || userActive == 'y')
    {
        printf("\n\n------- Binary Search Tree ------\n");
        printf("\n1. Insert");
        printf("\n2. Delete");
        printf("\n3. Search");
        printf("\n4. Get Larger Node Data");
        printf("\n5. Get smaller Node data");
        printf("\n\n-- Traversals --");
        printf("\n\n6. Inorder ");
        printf("\n7. Post Order ");
        printf("\n8. Pre Oder ");
        printf("\n9. Exit");
 
        printf("\n\nEnter Your Choice: ");
        scanf("%d", &userChoice);
        printf("\n");
 
        switch(userChoice)
        {
            case 1:
                data = get_data();
                insert(data);
                break;
 
            case 2:
                data = get_data();
                root = delete(root, data);
                break;
 
            case 3:
                data = get_data();
                if (search(data) == 1)
                {
                    printf("\nData was found!\n");
                }
                else
                {
                    printf("\nData does not found!\n");
                }
                break;
 
            case 4:
                result = largest_node(root);
                if (result != NULL)
                {
                    printf("\nLargest Data: %d\n", result->data);
                }
                break;
 
            case 5:
                result = smallest_node(root);
                if (result != NULL)
                {
                    printf("\nSmallest Data: %d\n", result->data);
                }
                break;
 
            case 6:
                inorder(root);
                break;
 
            case 7:
                postorder(root);
                break;
 
            case 8:
                preorder(root);
                break;
 
            case 9:
                printf("\n\nProgram was terminated\n");
                break;
 
            default:
                printf("\n\tInvalid Choice\n");
                break;
        }
 
        printf("\n__________\nDo you want to continue? ");
        fflush(stdin);
        scanf(" %c", &userActive);
    }
 
    return 0;
}
 
// creates a new node
struct node *create_node(int data)
{
    struct node *new_node = (struct node *)malloc(sizeof(struct node));
 
    if (new_node == NULL)
    {
        printf("\nMemory for new node can't be allocated");
        return NULL;
    }
 
    new_node->data = data;
    new_node->left = NULL;
    new_node->right = NULL;
 
    return new_node;
}
 
// inserts the data in the BST
void insert(int data)
{
    struct node *new_node = create_node(data);
 
    if (new_node != NULL)
    {
        // if the root is empty then make a new node as the root node
        if (root == NULL)
        {
            root = new_node;
            printf("\n* node having data %d was inserted\n", data);
            return;
        }
 
        struct node *temp = root;
        struct node *prev = NULL;
 
        // traverse through the BST to get the correct position for insertion
        while (temp != NULL)
        {
            prev = temp;
            if (data > temp->data)
            {
                temp = temp->right;
            }
            else
            {
                temp = temp->left;
            }
        }
 
        // found the last node where the new node should insert
        if (data > prev->data)
        {
            prev->right = new_node;
        }
        else
        {
            prev->left = new_node;
        }
 
        printf("\n* node having data %d was inserted\n", data);
    }
}
 
// deletes the given key node from the BST
struct node *delete (struct node *root, int key)
{
    if (root == NULL)
    {
        return root;
    }
    if (key < root->data)
    {
        root->left = delete (root->left, key);
    }
    else if (key > root->data)
    {
        root->right = delete (root->right, key);
    }
    else
    {
        if (root->left == NULL)
        {
            struct node *temp = root->right;
            free(root);
            return temp;
        }
        else if (root->right == NULL)
        {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = smallest_node(root->right);
        root->data = temp->data;
        root->right = delete (root->right, temp->data);
    }
    return root;
 
}
 
// search the given key node in BST
int search(int key)
{
    struct node *temp = root;
 
    while (temp != NULL)
    {
        if (key == temp->data)
        {
            return 1;
        }
        else if (key > temp->data)
        {
            temp = temp->right;
        }
        else
        {
            temp = temp->left;
        }
    }
    return 0;
}
 
// finds the node with the smallest value in BST
struct node *smallest_node(struct node *root)
{
    struct node *curr = root;
    while (curr != NULL && curr->left != NULL)
   {
        curr = curr->left;
    }
    return curr;
}
 
// finds the node with the largest value in BST
struct node *largest_node(struct node *root)
{
    struct node *curr = root;
    while (curr != NULL && curr->right != NULL)
    {
        curr = curr->right;
    }
    return curr;
}
 
// inorder traversal of the BST
void inorder(struct node *root)
{
    if (root == NULL)
    {
        return;
    }
    inorder(root->left);
    printf("%d ",  root->data);
    inorder(root->right);
}
 
// preorder traversal of the BST
void preorder(struct node *root)
{
    if (root == NULL)
    {
        return;
    }
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}
 
// postorder travsersal of the BST
void postorder(struct node *root)
{
    if (root == NULL)
    {
        return;
    }
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}
 
// getting data from the user
int get_data()
{
    int data;
    printf("\nEnter Data: ");
    scanf("%d", &data);
    return data;
}

---------------------

DIJIKSTRA

#include<stdio.h>
#include<stdlib.h>

void dijkstra(int n,int s,int dist[],int cost[][10]){
    int i,v,count=1,min,visited[10];
    for(i=1;i<=n;i++){
        visited[i]=0;
        dist[i]=cost[s][i];
    }
    visited[s]=1;
    dist[s]=0;
    while(count<=n){
        min=999;
        for(i=1;i<=n;i++){
           if(dist[i]<min && visited[i]==0){
               min=dist[i];
               v=i;
           } 
        }
        visited[v]=1;
        count++;
        for(i=1;i<=n;i++){
            if(dist[i]>dist[v]+cost[v][i]){
                dist[i]=dist[v]+cost[v][i];
            }
        }
    }
}

int main(){
    int i,j,n,s,d,dist[10],cost[10][10];
    printf("\nEnter the no of nodes : ");
    scanf("%d",&n);
    printf("\nEnter the cost matrix : \n");
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            printf("Cost matrix[%d][%d] : ",i,j);
            scanf("%d",&cost[i][j]);
            if(cost[i][j]==0){
                cost[i][j]=999;
            }
        }
    }
    printf("\nEnter the source node : ");
    scanf("%d",&s);
    printf("\nEnter the destination node : ");
    scanf("%d",&d);
    dijkstra(n,s,dist,cost);
    printf("\nShortest path for source node %d is ",s);
    for(i=1;i<=n;i++){
        if(s!=i && d==i){
            printf("\n%d -> %d = %d",s,i,dist[i]);
        }
    }
    return 0;
}


----------------------------------------


HEAP.C

#include<stdio.h>
int heap[50];

void swap(int *a,int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

void heapify(int n,int i)
{
    int lar = i;
    int l = (2*i)+1;
    int r = (2*i)+2;
    if (l<n&&heap[l]>heap[lar]) lar = l;
    if (r<n&&heap[r]>heap[lar]) lar = r;
    if (lar!=i)
    {
        swap(&heap[lar],&heap[i]);
        heapify(n,lar);
    }
}

int insert(int n)
{
    int node,i;
    printf("\nEnter the node: ");
    scanf("%d",&node);
    heap[n++]=node;
    for(i=n/2-1;i>=0;i--) heapify(n,i);
    return n;
}

int del(int n)
{
    int node,i;
    printf("\nEnter the node: ");
    scanf("%d",&node);
    for(i=0;i<n;i++) if(heap[i]==node) break;
    if(i!=n)
    {   printf("%d is deleted.\n",heap[i]);
        swap(&heap[i],&heap[n-1]); 
        n--;
        for(i=n/2-1;i>=0;i--) heapify(n,i);
    }
    return n;
}

void minheap(int n)
{
    int i;
    for(i=n-1;i>0;i--)
    {
        swap(&heap[i],&heap[0]); 
        heapify(i,0);
    }
}

void print(int n)
{
    printf("Heap Level Order\n");
    for(int j=0;j<n;j++) printf("%d  ",heap[j]); printf("\n");
    printf("\n");
}

void display(int n,int i,int space)
{
    if (i<n)
    {
        int l = (2*i)+1;
        int r = (2*i)+2;
        space+=1;
        display(n,r,space);
        for(int j=1;j<space;j++) 
            printf("\t");
        printf("%d\n",heap[i]);
        display(n,l,space);
    }
}

int main()
{
    int ch,n = 0;
   

    while(1)
    {
    printf("\nEnter the choice: ");
    scanf("%d",&ch);
    switch(ch)
        {
            case 1: n = insert(n);
                    print(n);
                    printf("Heap as tree\n");
                    display(n,0,0);
                    break;
            case 2: n = del(n);
                    print(n);
                    printf("Heap as tree\n");
                    display(n,0,0);
                    break;
            case 3: minheap(n);
                    print(n);
                    display(n,0,0);
                    break;
            default: printf("\nWrong Choice\n");
        }
    }
}

---------------------------

HEAP2.c

#include <stdio.h>
#include<conio.h>
#include<stdlib.h>
int H[10];
int GAP=1;
int n;
int size=0;
void call(int i);
void Insert(int A[],int n) 
{
size++; 
 int i=n,temp; 
 temp=A[i]; 
 while(i>1 && temp>A[i/2]) 
 { 
 A[i]=A[i/2]; 
 i=i/2; 
 } 
 A[i]=temp; 
} 

int Delete(int A[],int n) 
{ 
  size--;
 int i,j,x,temp,val; 
 val=A[1]; 
 x=A[n]; 
 A[1]=A[n]; 
 //A[n]=val; 
 i=1;j=i*2; 
 while(j<=n-1) 
 { 
 if(j<n-1 && A[j+1]>A[j]) 
 j=j+1; 
 if(A[i]<A[j]) 
 { 
	 temp=A[i]; 
	 A[i]=A[j]; 
	 A[j]=temp; 
	 i=j; 
	 j=2*j; 
 } 
 else
 break; 
 } 
 return val; 
} 
void display()
{
	 int i;
 for(i=1;i<=size;i++) 
 {
   call(i);
  printf("%d ",H[i]);	
 }
}
int main()
{ 
 
 int i=1,choice; 
// printf("Enter the size of array:");
 //scanf("%d",&n);
 /*for(i=1;i<=n;i++)
 {
 	printf("\nEnter data:");
 	scanf("%d",&H[i]);
 	Insert(H,i);
 	display();
 	
 }*/
  
  
 // for(i=2;i<=n;i++) 
    

 while(1)
 {
 	printf("\n1.Insert");
 	printf("\n2.Delete");
 	printf("\n3.Display");
 	printf("\n4.Exit");
 	printf("Enter your choice:");
 	scanf("%d",&choice);
 	switch(choice)
 	{
 	 case 1:
 	 		printf("\nEnter data:");
 	        scanf("%d",&H[i]);
 	        Insert(H,i);
 	        i++;
 	        display();
	  break;
	  case 2:
	  	printf("Deletd item:%d ", Delete(H,i));
	  	printf("\n");
	  	//display();
	  break;
	  case 3:
	  	display();
	   break;
	   case 4:
	   exit(0); 	
	}
 }
 
 for(i=1;i<=n;i++) 
 {
   call(i);
  printf("%d ",H[i]);	
 }
 
 
 /*
 printf("\n");
 printf("%d ", Delete(H,n));
 printf("\n");
 n--;
 for(i=1;i<=n;i++) 
 printf("%d ",H[i]);
 
 /*for(i=7;i>1;i--) 
 { 
   Delete(H,i); 
 } 
 printf("\n");
 printf("%d ", Delete(H,7));
 printf("\n");

 
 for(i=1;i<=7;i++) 
 printf("%d ",H[i]); 
 printf("\n"); */
 
 return 0; 
}
void call(int i)
{
 	if(i==1)
 	 printf("\t\t  ");if(i==2)printf("\n\n\t  ");if(i==3)printf("\t\t\t");if(i==4)printf("\n\n ");if(i==5)printf("\t\t");if(i==6)printf("\t");if(i==7)
 	printf("\t\t");
 //	if(i==8)
 //	printf("\t\t\t");
}


---------------------------

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void insertion_sort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
 
        /* Move elements of arr[0..i-1], that are
          greater than key, to one position ahead
          of their current position */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

void main(){
    int arr[6] = {20,10,90,80,40,30};
    for (int i = 0; i < 6; i++)
    {
        printf("%d--",arr[i]);
    }
    printf("\n");
    insertion_sort(arr,6);
    for (int i = 0; i < 6; i++)
    {
        printf("%d--",arr[i]);
    }
    printf("\n");
}

----------------------------


KRUS.C


#include<stdio.h>
#include<stdlib.h>
int v,n;

typedef struct edge{
    int u,v,w;
} edge;

void DisplayKruskal(int size);
void Display(int adj[][v]);
edge elist[20], span[20];

void sort(){
    edge temp;
    for(int i = 1; i < n; i++){
        for(int j = 1; j < n-i; j++){
            if(elist[j].w > elist[j+1].w){
                temp = elist[j];
                elist[j] = elist[j+1];
                elist[j+1] = temp;
            }
        }
    }
}

// int find(int belongs[], int i){
//     // while(belongs[i]){
//     //     i = belongs[i];
//     //     return i;
//     // }
//     return belongs[i];
//         //    i = belongs[i];
//         //    return i;
// }
void Union(int belongs[], int i, int j){
    for(int k = 0; k <= v; k++){
        if(belongs[k] == j){
            belongs[k] = i;
        }
    }
}

void Kruskal(int adj[][v]){
    int belongs[20],sn = 1,cn1,cn2;
    n = 1;
    for(int i = 1; i <= v; i ++){
        for(int j = 1; j <= v; j++){
            if(adj[i][j] != 0){
                elist[n].u = i;
                elist[n].v = j;
                elist[n].w = adj[i][j];
                n++;
            }
        }
    }
    sort();

    for(int i = 1; i < n; i++){
        // cn1 = find(belongs,elist[i].u);
        // cn2 = find(belongs,elist[i].v);
        cn1 = belongs[elist[i].u];
        cn2 = belongs[elist[i].v];

        if(cn1!= cn2){
            span[sn] = elist[i];
            sn++;
            Union(belongs, cn1, cn2);
        }
    }
    DisplayKruskal(sn);
}

void init(int adj[][v]){
    for(int i = 1; i <= v; i++){
        for(int j = 1; j <= v; j++){
            adj[i][j] = 0;
        }
    }
}
void DisplayKruskal(int size){
    int i, cost= 0;
    for(i = 1; i < size; i++){
        printf("\nedge(%d,%d) : %d", span[i].u, span[i].v, span[i].w);
        cost = cost + span[i].w;
    }
    printf("\nCost : %d", cost);

}

void Display(int adj[][v]){
     for(int i = 1; i <= v; i++){
        for(int j = 1; j <= v; j++){
            printf("%d  ", adj[i][j]);
        }
        printf("\n");
    }    
}

void main(){
    int choice;
        printf("\nLet's create graph first\n");
        printf("\nNumber of vetices: ");
        scanf("%d",&v);
    int adj[v][v];
    init(adj);
        adj[1][1] = 0 ;
        adj[1][2] = 1 ;
        adj[1][3] = 7 ;
        adj[1][4] = 10 ;
        adj[1][5] = 5 ;

        adj[2][1] = 1 ;
        adj[2][2] = 0 ;
        adj[2][3] = 3 ;
        adj[2][4] = 0 ;
        adj[2][5] = 0 ;

        adj[3][1] = 7 ;
        adj[3][2] = 3 ;
        adj[3][3] = 0 ;
        adj[3][4] = 4 ;
        adj[3][5] = 0 ;

        adj[4][1] = 10 ;
        adj[4][2] = 0 ;
        adj[4][3] = 4 ;
        adj[4][4] = 0 ;
        adj[4][5] = 2 ;

        adj[5][1] = 5 ;
        adj[5][2] = 0 ;
        adj[5][3] = 0 ;
        adj[5][4] = 2 ;
        adj[5][5] = 0 ;

    Kruskal(adj);

}

---------------------



PRIMS1.C

#include<stdio.h>

int prims(int graph[][10],int n);
int a,b,u,v,n,i,j,ne=1;
int visited[10]={0},min,mincost=0,graph[10][10],cost[10][10];
 
void main()
{
	printf("\nEnter the number of nodes:");
	scanf("%d",&n);
	printf("\nEnter the adjacency matrix:\n");
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	{
		printf("Graph[%d][%d] : ",i,j);
		scanf("%d",&graph[i][j]);
	}
	prims(graph,n);
}

int prims(int graph[][10],int n){
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			if(graph[i][j]==0){
				cost[i][j]=999;
			}
			else{
				cost[i][j]=graph[i][j];
			}
		}
	}
	visited[1]=1;
	printf("\n");
	while(ne < n)
	{
		min=999;
		for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
		if(cost[i][j]<min&&visited[i]!=0)
		{
			min=cost[i][j];
			a=u=i;
			b=v=j;
		}
		if(visited[u]==0 || visited[v]==0)
		{
			printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
			mincost+=min;
			visited[b]=1;
		}
		cost[a][b]=cost[b][a]=999;
	}
	printf("\n Minimun cost=%d",mincost);
}
	

 
 
 
 -------------------------------

PRIMS.C

#include<stdio.h>
int v;
void Prims(int adj[][v]){
    int arr[20] = {0},ne = 0,x,y,min,cost=0;
    x = y = 0;
    arr[1] = 1;
    while(ne < v-1){
        x = 0;
        y  = 0;
        min = 999;
        for(int i = 1; i <= v && arr[i] == 1 ; i++){
            for(int j = 1; j <= v; j++){
                if(arr[j] == 0 && adj[i][j]!=0){
                    if(min > adj[i][j]){
                        min = adj[i][j];
                        x = i;
                        y = j;
                    }
                }
            }
        }
        printf("%d to %d : %d\n",x,y,adj[x][y]);
        cost=cost+adj[x][y];
        arr[y] = 1;
        ne++;
    } printf("The total cost of the minimum spanning tree is %d",cost) ;
}
void main(){
    int choice;
    v = 5;
    int adj[v][v];
        adj[1][1] = 0 ;
        adj[1][2] = 1 ;
        adj[1][3] = 7 ;
        adj[1][4] = 10 ;
        adj[1][5] = 5 ;

        adj[2][1] = 1 ;
        adj[2][2] = 0 ;
        adj[2][3] = 3 ;
        adj[2][4] = 0 ;
        adj[2][5] = 0 ;

        adj[3][1] = 7 ;
        adj[3][2] = 3 ;
        adj[3][3] = 0 ;
        adj[3][4] = 4 ;
        adj[3][5] = 0 ;

        adj[4][1] = 10 ;
        adj[4][2] = 0 ;
        adj[4][3] = 4 ;
        adj[4][4] = 0 ;
        adj[4][5] = 2 ;

        adj[5][1] = 5 ;
        adj[5][2] = 0 ;
        adj[5][3] = 0 ;
        adj[5][4] = 2 ;
        adj[5][5] = 0 ;
        Prims(adj);
}

-----------------
QUICK SORT.c

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void swap(int *a, int *b) {
  int t = *a;
  *a = *b;
  *b = t;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quick_sort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quick_sort(arr, low, pi - 1);
        quick_sort(arr, pi + 1, high);
    }
}

void main(){
    int arr[6] = {2,10,90,80,40,30};
    for (int i = 0; i < 6; i++)
    {
        printf("%d--",arr[i]);
    }
    printf("\n");
    quick_sort(arr,1,6);
    for (int i = 0; i < 6; i++)
    {
        printf("%d--",arr[i]);
    }
    printf("\n");
}


------------------------------


MERGESORT.c

#include<stdio.h>
#include<stdlib.h>
#define MAX 100
void copy(int arr[],int temp[],int low,int up);
void merge(int arr[],int temp[],int low1,int up1,int low2,int up2);
void merge_sort(int arr[],int low,int up)
{
	int mid;
	int temp[MAX];
	if(low<up)
	{
		mid=(low+up)/2;
		merge_sort(arr,low,mid);
		merge_sort(arr,mid+1,up);
		merge(arr,temp,low,mid,mid+1,up);
		copy(arr,temp,low,up);
	}
}
void merge(int arr[],int temp[],int low1,int up1,int low2,int up2)
{
	int i=low1;
	int j=low2;
	int k=low1;
	while((i<up1)&&(j<=up2))
	{
		if(arr[i]<=arr[j])
		 temp[k++]=arr[i++];
		else
		  temp[k++]=arr[j++];
	}
	while(i<=up1)
	  temp[k++]=arr[i++];
	while(j<=up2)
	   temp[k++]=arr[j++];
}
void copy(int arr[],int temp[],int low,int up)
{
	int i;
	for(i=low;i<=up;i++)
	{
		arr[i]=temp[i];
	}
}
int main()
{
	int arr[MAX],arr2[MAX],arr3[MAX],n1,n2,i;
	printf("Enter the size of first Array:");
	scanf("%d",&n1);
	printf("Enter Ele:");
	for(i=0;i<n1;i++)
	{
		scanf("%d",&arr);
	}
	
	merge_sort(arr,0,n1-1);
	printf("Merge list:\n");
	for(i=0;i<n1;i++)
	  printf("%d",arr[i]);
}

---------------------------------


MATMUL.c

#include <stdio.h>
int n=100;
   int minMul[10][10];
int MatrixChainMultuplication(int arr[], int n) {
   int j, q;
   for (int i = 1; i < n; i++)
      minMul[i][i] = 0;
   for (int L = 2; L < n; L++) {
      for (int i = 1; i < n - L + 1; i++) {
         j = i + L - 1;
         minMul[i][j] = 99999999;
         for (int k = i; k <= j - 1; k++) {
            q = minMul[i][k] + minMul[k + 1][j] + arr[i - 1] * arr[k] * arr[j];
            if (q < minMul[i][j])
            minMul[i][j] = q;
         }
      }
       for(int i=1;i<n;i++){
       for(int j=1;j<n;j++){
           printf("%d\t",minMul[i][j]);
       }
       printf("\n");
   }
   printf("\n");
  
   }
   return minMul[1][n - 1];
}
int main(){
   int arr[10],size;
   printf("enter the size :");
   scanf("%d",&size);
   for(int i=0;i<size;i++){
       printf("p%d :",i);
       scanf("%d",&arr[i]);
   }
   
  // int size = sizeof(arr) / sizeof(arr[0]);
   printf("Minimum number of multiplications required for the matrices multiplication is %d ",    MatrixChainMultuplication(arr, size));
   getchar();
   return 0;
}


